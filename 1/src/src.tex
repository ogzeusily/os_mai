\section{Метод решения}
В Unix-пути используются системные вызовы: os\_pipe, os\_fork, os\_dup2, os\_execl, os\_read, os\_write, os\_waitpid, а также примитивы для работы с файлами. Для переносимости — обёртки в linux/os\_linux.c и .

Программа строит конвейер из двух дочерних процессов:

parent — читает строку и подает ее в stdin первого дочернего процесса (child1);

child1 — переводит символы в нижний регистр;

child2 — удаляет повторяющиеся пробелы;

результат читается из второго канала родителем и выводится в stdout.

Кроссплатформенность достигается сборкой с разными реализациями os\_linux.h и win\_api.h:

Unix: parent.c + linux/os\_linux.c, include\_directories(linux);

Windows: parent.c + win/win\_api.c, include\_directories(win).

\section{Описание программы}

\texttt{parent.c} --- точка входа в программу. Создаёт два дочерних процесса, организует передачу данных между ними через каналы и выводит итоговый результат обработки строки.

\texttt{child1.c} --- исполняемый файл первого дочернего процесса. Преобразует все символы входного потока в строчные (нижний регистр) и выводит результат в стандартный поток вывода.

\texttt{child2.c} --- исполняемый файл второго дочернего процесса. Удаляет повторяющиеся пробелы из входного потока (оставляет только один пробел подряд) и выводит результат в стандартный поток вывода.

\texttt{os\_linux.h} --- объявление функций-обёрток над системными вызовами ОС Linux для управления процессами и каналами.  
\texttt{os\_linux.c} --- реализация (подразумевается, но не приведена в коде; используется в \texttt{parent.c}).  
Основные функции:
\begin{itemize}
\item \texttt{int os\_pipe(OsPipe fds);} --- создаёт канал, заполняя массив \texttt{fds} двумя файловыми дескрипторами (чтение/запись). Обёртка над \texttt{pipe()}.
\item \texttt{pid\_t os\_fork(void);} --- создаёт дочерний процесс. Обёртка над \texttt{fork()}.
\item \texttt{int os\_close(int fd);} --- закрывает файловый дескриптор. Обёртка над \texttt{close()}.
\item \texttt{int os\_dup2(int oldfd, int newfd);} --- дублирует файловый дескриптор \texttt{oldfd} в \texttt{newfd}. Обёртка над \texttt{dup2()}.
\item \texttt{ssize\_t os\_read(int fd, void *buf, size\_t count);} --- читает данные из файлового дескриптора. Обёртка над \texttt{read()}.
\item \texttt{ssize\_t os\_write(int fd, const void *buf, size\_t count);} --- записывает данные в файловый дескриптор. Обёртка над \texttt{write()}.
\item \texttt{pid\_t os\_waitpid(pid\_t pid, int *wstatus, int options);} --- ожидает завершения указанного процесса. Обёртка над \texttt{waitpid()}.
\item \texttt{int os\_exec(const char *path, const char *arg0);} --- заменяет текущий процесс новым исполняемым файлом. Обёртка над \texttt{execl()}.
\item \texttt{int os\_is\_child\_process(void);} --- проверяет, является ли текущий процесс одним из созданных дочерних (вспомогательная логика инициализации).
\item \texttt{void os\_init\_child\_process(void);} --- инициализирует внутреннее состояние для корректной работы \texttt{os\_is\_child\_process()} и \texttt{os\_get\_fork\_number()}.
\item \texttt{int os\_get\_fork\_number(void);} --- возвращает порядковый номер дочернего процесса (для отладки/идентификации).
\end{itemize}

\vspace{2\baselineskip}

Архитектура взаимодействия:

Родительский процесс (\texttt{parent.c}) считывает строку от пользователя, создаёт три канала:  
\begin{itemize}
    \item \texttt{pipe1} — от родителя к \texttt{child1},
    \item \texttt{pipe\_mid} — от \texttt{child1} к \texttt{child2},
    \item \texttt{pipe2} — от \texttt{child2} обратно к родителю.
\end{itemize}
Первый дочерний процесс (\texttt{child1}) получает исходную строку, переводит все символы в нижний регистр и передаёт результат через промежуточный канал.  
Второй дочерний процесс (\texttt{child2}) получает эту строку, удаляет повторяющиеся пробелы и отправляет финальный результат в последний канал.  
Родитель ожидает завершения обоих дочерних процессов, читает результат из \texttt{pipe2} и выводит его на экран.